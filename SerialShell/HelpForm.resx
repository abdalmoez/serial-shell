<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="metroLabel1.Text" xml:space="preserve">
    <value>Serial communication is characterized by:
 + The speed of transferring data BAUD (number of bits in a second).
 + Data size 7bits (used to send ascii code) or 8bits.
 + Parity used to check if data where not changed when sending it you can select: Even, Odd, None, Mark or Space.
 + Stop bits : before sending data in serial communication we send a start bit then the data and finally we end by stop bits it can be 1,1.5 or 2bits.</value>
  </data>
  <data name="metroLabel2.Text" xml:space="preserve">
    <value> "Connect" tab:
Before starting a communication you must select the serial port where the device you wish to use is connected then select your port configuration 
(every time you active the combo Box it will automatically scan all serial ports).If you are a beginner you can use button "Beginner configuration" to
 select the default configuration used by all devices then press button connect.</value>
  </data>
  <data name="metroLabel3.Text" xml:space="preserve">
    <value> "Send" tab
In this tab you can select data type of what you’d like to send.
Example: if you'd like to send a float you can select in data type section "float" and write your number in message section then press enter.
You can use ending line:
          - None
          - Windows (CR LF) : Carriage return + Line feed
          - Macintosh (CR): Carriage return 
          - Unix (LF): Line feed
You can also send a file:
          1- Press "browse" button
          2- Select your file
          3- Press "send" button
"Shortcut Settings" button open a dialog to configure shortcuts for keyboard you can use (CTRL0,CTRL1,CTRL2,CTRL3,CTRL4,CTRL5,CTRL6,CTRL7,
CTRL8,CTRL9) or for joystick buttons.</value>
  </data>
  <metadata name="metroStyleManager.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>




                                                          SerialShell V0.1 Manual
                                                                                  Copyright 2016




Summary:
	I.	Introduction
	II.	Connecting your device
	III.	Sending data
	IV.	Receiving data
	V.	License
	VI.	Contact us


I.	Introduction
		SerialShell is an advanced application used to send and receive data using a serial port. 
		You can use your joystick or your keyboard as shortcut system to send predefined data or 
		send costumed data messages. This application allows you to select your data type (string,
		C-Like string, float, byte, word …) and you will have a total access to your serial port 
		device using the advanced tools.
II.	Connecting your device:
		Connection tab is used to connect to your Serial Port device, so you have to specify the 
		port COM? Data transfer speed in BAUD and other information that your device used so be 
		careful you have to configure your application correctly to get it work.
		List of connection settings:
		•	Port:
		In this combo box you have to specify your port so if you used COM1 you have to set this 
		field to COM1. Every time you drop down the combo box the application will scan all serial 
		ports available for use.
		•	Baud:
		Here you have to specify the data rate or data speed if you use another speed than the 
		hosted port, you will lose your data when sending, so if your hosted device use a speed 
		of 9600baud you have to set this field to 9600baud.
		The evaluable values are: 300, 1400, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400,
		250000. All these values are in BAUD unit. 
		•	Data Size:
		Here you specify your device sending data size 8 bits or 7 bits.
		•	Stop Bits:
		Number of stop bits used in transferring data 1, 1.5 or 2.
		•	Parity:
		This field is used to check if the data are correctly received so you have to specify what
		type of checking the data. The available values are: ‘Even’, ‘Odd’, ‘None’, ‘Mark’ and ‘Space’.

		If you are a beginner and you don’t know what to set you can use “Beginner Configuration”
		so this will set the default values used in the most application:
			Baud: 9600
			Data Size: 8 bits
			Stop Bits: 1
			Parity: None
		After entering the correct settings use the connect button if there is a connection error 
		it will be displayed in the Host Monitor.




III.	Sending data:


		There is three ways to send data:
		•	Select a file and then press send button to send all the data in this file. It can be 
		a text file or binary file.
		•	Sending a costumed message so every time you’d like to send message you have to write
		it and press “ENTER” button. You can select your data type using the data type combo box. 
		Also you can choose the data ending:
			§	None
			§	Windows (CR LF)
			§	Macintosh (CR)
			§	Unix (LF)
		The available data types are: 
			o	String
			o	Verbatium string: C-Like String \0 \n \r \t …
			o	Float 32 bits
			o	Byte 
			o	Signed byte
			o	Word 
			o	Signed word
			o	Double word
			o	Signed double word
		You can select the datatype every time you want to send or receive data.
		•	Sending predefined shortcut messages.
		The available shortcuts are:
			o	For keyboard:
				§	ALT+0
				§	ALT+1
				§	ALT+2
				§	ALT+3
				§	ALT+4
				§	ALT+5
				§	ALT+6
				§	ALT+7
				§	ALT+8
				§	ALT+9
				For these is shortcuts you can select the data type and set your data.
			o	For joystick:
				§	Button 1
				§	Button 2
				§	Button 3
				§	Button 4
				§	L1
				§	L2
				§	L3
				§	R1
				§	R2
				§	R3
				§	Up
				§	Down
				§	Left
				§	Right
				§	Start
				§	Select
		For these is shortcuts you can select the data type, set your data when pressing and when 
		releasing the key. The check box repeat is used to always send data until your release the 
		pressed key.
		Empty messages are ignored.  
		If there is an error in sending data, the current port will be released and the error message
		will be displayed in the Host Monitor.
IV.	Receiving data:

		All received data will be displayed in the Guest Monitor. 
		You can select the data types (String, Float 32 bits, Byte, Signed byte, Word, Signed word, 
		Double word, Signed double word).
		You can also save the received data in a log file so the same result in the Guest Monitor 
		will be written in a log file. This tools can be enabled or disabled using the enable button. 
		To change the path, you can use the browse button select the destination file and confirm.
V.	License
		You can distribute this software but you can’t sell it. Reverse engineering are prohibited. We are 
		not responsible for any damage encountered by the user. If you use this software, you are accepting
		this license.
VI.	Contact:
		For more information you can contact us on: bouraoui.almoez.la@gmail.com
		If there is any bug, please report it and we will fix it as soon as possible.</value>
  </data>
</root>